варианты асинхронного взаимодействия

Queue - продюсер -> очередь -> потребитель
Worker Queue - продюсер -> рабочая очередь -> консьюмеры
Publish/Subscribe - продюсер -> копируется и в одну очередь, и в другую -> консьюмеры на каждой. т.е. одно событие, но для разных по функционалу сервисы.
Topic - продюсер -> копируется и в одну очередь, и в другую -> консьюмеры на каждой. т.е. каждый из сервисов может подписаться на несколько событий - именно на те, которые ему интересны
RPC (реализованная через очередь) - продюсер(после отправки события в очередь переходит в ожидание) -> обычная очередь -> консьюмер -> очередь обратных вызовов -> продюсер(после получения коллбэка просыпается). возможна полезность в высоконагруженных системах, когда сообщения нужно обрабатывать очень быстро, т.к. фут принт при отправке сообщений - меньше, amqp - компактен, tcp - держит соединение постоянно, payload - всё, что можно превратить в строку, rabbitMQ передаёт данные в бинарном виде(нет необходимости в передаче заголовков), в итоге обмен сообщений быстр

особенности:
клиент, вызывающий код, не блокируется после выполнения запроса
клиент получит результат запроса позднее

Брокеры сообщений:
RabbitMQ (Erlang/OTP)
EMQ X Broker (Erlang/OTP)
Apache Kafka (Java, Scala)
NATS (Go)
NSQ (Go)

RabbitMQ
Язык: Erlang/OTP,
Поддерживает протоколы: AMQP, MQTT, STOMP, вомзожен websocket
Поддерживается персисетнтность сообщений (т.е. при настройке сохранения сообщений на диск, после падения rabbit, легко вернуть очередь с консистентными сообщениям. важно заметить, что если уже сам микросервис упадёт после rpc-запроса, и черз какое-то время обратно поднимется, то возможен вариант, что в микросервис-хост придёт два запроса. т.о. надо реализовать иденпотентность обработки таких сообщений)
Поддержка плагинов (даже своих)
Гибкий роутинг сообщений
Встроенные возможности мониторинга
Хороша реализована возможность объединяться в кластер, распределённый деплой в кластере, high loadability (доп надёжность при нагрузке)
например, для кафки - апач зукипер.
либы на языках: ruby, python, js, elixir, java

В реббите асинхронное взаимодействие происходит через:
продюсер(шлёт по routing_key) -> exchanger(почт. ящик, обязательно со своим названием - route_name) -> очередь(и), кот. биндится строго к своему ящику (т.е. по маске, например: *.events.* и/или service.events.*)

Если не задавать роутинги, то очередь сама привяжется к дефолтному ящику (default exchanger). например, нужно чтобы просто реализовать Queue
В RabbitMQ существует механизм по созданию callback-очереди, при котором создаётся псевдо-очередь для обратных вызовов. полезен, в несложных системах, для облегчения механизма rpc. подписаться на неё можно только один раз на канал.

клиенты для RabbitMQ:
Bunny (feature-complete, содержит всё, что нужно, кроме надстройки для асинхр взаимодействия)
Hutch (лёгок для асинхрона)
Sneakers (аналог Sidekiq, в итоге, для rails rabbitMQ можно испозовать вместо Redis). из коробки не регламентирует паблишинг событий. реализует только конъюмеры. не сильно привязывается к стеку - можно на чистом руби поднимать микросервис.





при старте контейнера с rabbitmq необходимо указывать имя hostname, т.к. путь к каталогу с хранимыми мета-данными об очередях, и пр. данными о своей работе, формируется на основе имени hostname. если не задать - после рестарта контейнера получилось бы так, что старые данные будут утеряны.

канал - логическое соединение между клиентом и нодой rabbitmq (можно создать один только для публикаций, другой только потребления. ибо один канал при большой нагрузке лучше не использовать. затем, эти каналы мультиплексируются в одно физическое соединение)
connection - физическое tcp соединение

у rabbitmq есть exchanges:
amq.direct - расслыка сообщений по тем биндингам(очередям), которые определены
amq.fanout - дублирует сообщение(оно будет склонировано) по всем биндингам, которые к этому exchange привязаны
amq.headers - биндит очереди не с помощью routing_key, а с помощью заголовков(мето данные, передаваемы по желанию. т.е. по нашим правилам.)






реализация продюсера:
require 'bunny'

# Producer -> Default Exchange -> Queue -> Consumer
class Producer
  def initialize(queue:)
    @connection = Bunny.new.start
    @channel = @connection.create_channel
    @queue = @channel.queue(queue)
  end

  def publish(payload)
    # паблишинг сообщений в дефолтный exchange
    @channel.default_exchange.publish(payload, routing_key: @queue.name)

    # паблишинг напрямую в очередь (на самом деле так же через дефолтный exchange)
    # @channel.publish(payload)
  ensure
    @connection.close
  end
end

producer = Producer.new(queue: 'tasks').publish('payload')


реализация консъюмера:
require 'bunny'

class Consumer
  def initialize(queue:)
    @connection = Bunny.new.start
    @channel = @connection.create_channel
    @queue = @channel.queue(queue)

    # чтобы очередь после рестарта rabbitmq сохраняло последнее состояние(для коллбэк очередей не обязательно), её нужно сделать durable: true
  end

  def start
    # delivery_info - нифа о сообщении, например, для отправки ack данных (чтобы rabbit удалил сообщение из очереди)
    # properties - мета, можно пробросить свои параметры в ключе headers
    # payload - пересылаемые данные
    @queue.subscribe do |delivery_info, properties, payload|
      # вызов метода @queue.subscribe не блокирующий.
      # код в этом блоке будет выполняться не в главном треде, а в треде пула.
      # связано с тем, что за обработку событий @queue.subscribe отвечает специальный тредпул.
      # при создании канала в этом тредпуле будет один воркер для обработки входящих сообщений, но число воркеров можно увеличить
      
      puts "Received: #{payload}"
    end

  end
end

consumer = Consumer.new(queue: 'tasks').start
puts 'Consumer started'

# важно не дать завершиться мейн треду, чтобы треды, создаваемые при @queue.subscribe не завершились.
loop { sleep 3 }

